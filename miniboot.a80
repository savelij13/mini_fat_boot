
; LAST UPDATE 21.06.2021 savelij

; загрузчик и запускатель файлов в Hobeta формате с SD карты

		include ../../yad/svn/pentevo/rom/macros.a80
		include ../../yad/svn/pentevo/rom/sdcomand.a80
		include define.a80

;PARSER_PATH	; требует переделки, пока отключен

SD_RSTR		EQU P_DATA
SD_SEND		EQU P_DATA

; Входные параметры общие:
; HL-адрес загрузки в память
; BCDE-32-х битный номер сектора
; A-количество блоков (блок=512 байт)
; только для многоблочной записи/чтении

; Ошибки выдаваемые на выходе:
; A=0-инициализация прошла успешно
; A=1-карта не найдена или не ответила
; A=2-карта защищена от записи
; A=3-попытка записи в сектор 0 карты

 INIT_VAR PEREM
 SETVAR TDIRCLS,		0x400	;EQU PEREM		; 0x400 буфер кластеров ROOT директории
 SETVAR BUF_512,		0x200	;EQU TDIRCLS+0x0400	; 0x200 буфер сектора
 SETVAR CACHE_SEC,		0x200				; 0x200 кеш сектора для разбора Hobeta заголовка
 SETVAR CAL_FAT,		BYTE	;EQU BUF_512+0x0200	; 1 калибр FAT
 SETVAR MANYFAT,		BYTE
 SETVAR BYTSSEC,		BYTE	;EQU CAL_FAT+1		; 1 количество секторов в кластере
 SETVAR ROOTCLS,		DWORD	;EQU BYTSSEC+1		; 4 сектор начала ROOT директории
 SETVAR ROOTSEC,		WORD	;EQU ROOTCLS+4		; 2 размер в секторах ROOT директории
 SETVAR SEC_FAT,		DWORD	;EQU ROOTSEC+2		; 4 количество секторов одной FAT
 SETVAR RSVDSEC,		WORD	;EQU SEC_FAT+4		; 2 размер резервной области
 SETVAR STARTRZ,		DWORD	;EQU RSVDSEC+2		; 4 начало диска/раздела
 SETVAR FRSTDAT,		DWORD	;EQU STARTRZ+4		; 4 адрес первого сектора данных от BPB
 SETVAR SEC_DSC,		DWORD	;EQU FRSTDAT+4		; 4 количество секторов на диске/разделе
 SETVAR CLS_DSC,		DWORD	;EQU SEC_DSC+4		; 4 количество кластеров на диске/разделе
 SETVAR FATSTR,			DWORD	;EQU CLS_DSC+4		; 4 начало первой FAT таблицы
 SETVAR ADRPATH,		WORD	;EQU FB_EXT+0x0B	; 2 адрес пути к имени файла
 SETVAR AFILCLS,		DWORD
 SETVAR LENGHT,			WORD

		ORG ADRLOAD
		DI
		LD SP,0x5FFF
		LD BC,0x7FFD
		LD A,0x10
		OUT (C),A
		LD HL,F_PATH
		CALL START			; инициализация SD карты, FAT и поиска файла
		AND A
		JP NZ,NOTFOUND			; файл не найден

		CALL REALSEC			; преобразовали в номер сектора
		CALL LOADLST			; загрузили в буфер
		EXX
		LD HL,(BUF_512+9)
		LD (RUN_ADR),HL			; адрес старта кода
		LD HL,(BUF_512+0X0B)
		LD (LENGHT),HL			; установка длины файла в байтах
		LD DE,0x11
		ADD HL,DE			; пропуск Hobeta заголовка
		LD A,L
		AND A
		JR Z,READ01			; если младший байт не 0
		INC H				; старший +1
READ01		LD A,H
		SRL A				; делим на 2 ибо на FAT сектор 512 байт
		ADC A,0				; учитываем чет/нечет
		DEC A				; первый сектор загружен, грузить на 1 меньше
		EXX
		JP Z,LDIRBUF			; если сектор 1 перенос и запуск
		DEC A
		LD IXL,A			; запомнили количество секторов-1
		JP Z,READ08			; если секторов 2 осталось загрузить кусок из второго сектора
		EXX
		CALL LD_ONES			; перенос остатков первого сектора
		PUSH DE				; адрес куда далее грузить
		EXX
		LD HL,1				; один сектор уже загружен
		ADD HL,DE			; далее грузить со следующего сектора 
		EX DE,HL
		JR NC,READ04
		INC BC				; BCDE++
READ04		POP HL				; в HL адрес для продолжения загрузки
		LD IY,(BYTSSEC)			; LY = количество секторов в кластере
		LD A,IXL
		CP IYL				; секторов осталось меньше чем в кластере
		JR C,READ02			; переход на дозагрузку остатка секторов
		INC IXL
		LD A,IYL
		CP 2
		JR C,READ07
		DEC A
		JR READ05

READ07		PUSH HL
		CALL RDFATZP			; получить номер следующего кластера
		CALL LST_CLS			; проверка на окончание FAT цепочки
		POP HL
		JR C,RUNLOAD			; если кластера закончились, то запуск загруженного
		PUSH HL
		CALL REALSEC			; преобразование номера кластера в номер сектора
		POP HL
		LD A,IXL			; сколько секторов осталось загрузить
		CP IYL				; сравниваем с размером кластера
		JR C,READ02			; если осталось загрузить секторов меньше чем в кластере, то дозагружаем остаток
		LD A,IYL			; сколько секторов загружать
READ05		CALL RDMULTI			; загрузка секторов
		LD A,IXL			; сколько секторов всего загружать
		SUB IYL				; минус сколько секторов только что загрузили
		JR Z,RUNLOAD			; сектора кончились, переходим на запуск
		LD IXL,A			; сколько секторов осталось загрузить
		JR READ07			; продолжаем загрузку

; размер кода в Hobeta менее 2 секторов
; копируем хвост первого сектора и догружаем из второго с переносом
READ08		EXX
		CALL LD_ONES
		PUSH DE
		EXX
		POP HL
		LD IXL,1
		JR READ03

; загрузка количества секторов, если осталось менее размера кластера
READ02		AND A
		JR Z,READ03
		CALL RDMULTI
READ03		PUSH HL
		LD A,IXL
		LD L,A
		LD H,0
		ADD HL,DE
		EX DE,HL
		JR NC,READ06
		INC BC
READ06		CALL LOADLST
		LD BC,(LENGHT)
		EX DE,HL
		LD HL,0X11
		ADD HL,BC
		LD B,H
		LD C,L
		EX DE,HL
		POP DE
		LD A,B
		AND 1
		LD B,A
		OR C
		JR Z,RUNLOAD
		LDIR
; запуск загруженного
RUNLOAD		LD HL,0X2758
		EXX
		LD IY,0x5C3A
		LD A,0x3F
		LD I,A
		IM 1
		EI
		JP 0			; запуск загруженного кода
RUN_ADR		EQU $-2

LDIRBUF		LD HL,0X200-0X11
		LD DE,(BUF_512+0X0B)
		AND A
		SBC HL,DE
		JR NC,LDIRBUF1
		CALL LD_ONES
		JP RUNLOAD

LDIRBUF1	LD HL,BUF_512+0X11
		LD DE,(BUF_512+9)
		LD BC,(BUF_512+0X0B)
		LDIR
		JP RUNLOAD

; перенос куска из уже загруженного сектора, если файл=501 байт и менее
LD_ONES		LD HL,BUF_512+0X11
		LD DE,(BUF_512+9)
		LD BC,0X200-0X11
		LDIR
		RET

; выдача ошибки "нет карточки"
ZAW003
		LD A,0xEE
		RET

; инициализация SD карты, FAT и поиск файла по имени
; на входе:
; HL - имя файла
; на выходе:
; BCDE - номер калстера файла
START
		LD (ADRPATH),HL

; ---------------------------------
; для Z-контроллера
		LD A,3
		OUT (P_CONF),A
		XOR A
		OUT (P_DATA),A
		LD BC,P_DATA
		LD DE,0x10FF
.L1		OUT (C),E
		DEC D
		JR NZ,.L1
		LD A,1
		OUT (P_CONF),A
		XOR A
		EX AF,AF'
;---------------------------------

ZAW001
		LD HL,CMD00
		CALL OUTCOM
		CALL IN_OOUT
		EX AF,AF'
		DEC A
		JR Z,ZAW003
		EX AF,AF'
		DEC A
		JR NZ,ZAW001
		LD BC,SD_RSTR
		LD HL,CMD08
		CALL OUTCOM
		CALL IN_OOUT
		IN H,(C)
		NOP
		IN H,(C)
		NOP
		IN H,(C)
		NOP
		IN H,(C)
		BIT 2,A
		LD HL,0
		JR NZ,ZAW006
		LD H,0x40
ZAW006		LD A,CMD_55
		CALL OUT_COM
		CALL IN_OOUT
		LD BC,SD_SEND
		LD A,ACMD_41
		OUT (C),A
		LD A,H
		OUT (C),A
		XOR A
		OUT (C),A
		NOP
		OUT (C),A
		NOP
		OUT (C),A
		DEC A
		OUT (C),A
		CALL IN_OOUT
		AND A
		JR NZ,ZAW006
ZAW004
		LD A,CMD_59
		CALL OUT_COM
		CALL IN_OOUT
		AND A
		JR NZ,ZAW004
ZAW005
		LD HL,CMD16
		CALL OUTCOM
		CALL IN_OOUT
		AND A
		JR NZ,ZAW005

; инициализация переменных FAT
WC_FAT
		LD DE,0
		LD B,D
		LD C,E
		CALL LOADLST
		PUSH HL
		POP IX
		LD DE,0x01BE
		ADD HL,DE
		LD A,(HL)
		AND A
		JR NZ,RDFAT05
		LD DE,4
		ADD HL,DE
		LD A,(HL)
		LD B,0
		CP 1
		JR Z,RDFAT06
		LD B,2
		CP 0x0B
		JR Z,RDFAT06
		CP 0x0C
		JR Z,RDFAT06
		LD B,1
		CP 6
		JR Z,RDFAT06
		CP 0x0E
		JR NZ,RDFAT05
RDFAT06
		LD A,B
		LD (CAL_FAT),A
		ADD HL,DE
		CALL LOADZP
		JR RDFAT00

RDFAT05
		LD C,(IX+0x0D)
		XOR A
		LD E,A
		LD B,8
.L1		RR C
		ADC A,0
		DJNZ .L1
		DEC A
		JR NZ,.L2
		INC E
.L2		LD A,(IX+0x0E)
		OR (IX+0x0F)
		JR Z,.L3
		INC E
.L3		LD A,(IX+0x13)
		OR (IX+0x14)
		JR NZ,.L4
		INC E
.L4		LD A,(IX+0x20)
		OR (IX+0x21)
		OR (IX+0x22)
		OR (IX+0x23)
		JR NZ,.L5
		INC E
.L5		LD A,(IX+0x15)
		AND 0xF0
		CP 0xF0
		JR NZ,.L6
		INC E
.L6		LD A,E
		CP 4
		LD A,0xDD
		RET NZ
		LD A,0xFF
		LD (CAL_FAT),A
		LD DE,0
		LD B,D
		LD C,E

RDFAT00
		LD (STARTRZ),DE
		LD (STARTRZ+2),BC
		CALL LOADLST
		LD HL,0
		LD DE,(BUF_512+0x16)		
; BPB_FATSZ16
		LD A,D
		OR E
		JR NZ,RDFAT01
; если не FAT12/16 (BPB_FATSZ16=0)
		LD DE,(BUF_512+0x24)
		LD HL,(BUF_512+0x26)
; BPB_FATSZ32
; то берем из смещения +36
RDFAT01
		LD (SEC_FAT+2),HL
		LD (SEC_FAT),DE
; число секторов на FAT-таблицу
		LD HL,0
		LD DE,(BUF_512+0x13)
; BPB_TOTSEC16
		LD A,D
		OR E
		JR NZ,RDFAT02
; если не FAT12/16 (BPB_TOTSEC16=0)
		LD DE,(BUF_512+0x20)
		LD HL,(BUF_512+0x22)
; BPB_TOTSEC32
; то берем из смещения +32
RDFAT02
		LD (SEC_DSC+2),HL
		LD (SEC_DSC),DE
; количество секторов на диске/разделе

; вычисляем ROOTDIRSECTORS
		LD BC,(BUF_512+0x0B)
; BPB_BYTSPERSEC
		LD DE,(BUF_512+0x11)
; BPB_ROOTENTCNT
		LD HL,0
		LD A,D
		OR E
		JR Z,RDFAT03
		LD B,H
		LD C,L
		LD A,0x10
		CALL BCDE_A
		EX DE,HL

; это реализована формула
; ROOTDIRSECTORS = ((BPB_ROOTENTCNT*32) + (BPB_BYTSPERSEC-1)) / BPB_BYTSPERSEC
; в HL ROOTDIRSECTORS
; если FAT32, то HL=0 всегда

RDFAT03
		PUSH HL				; ROOTDIRSECTORS
		LD (ROOTSEC),HL
		LD A,(BUF_512+0x10)
		LD (MANYFAT),A
		LD DE,(SEC_FAT)
		LD HL,(SEC_FAT+2)
		DEC A
.L1		EX DE,HL
		ADD HL,HL
		EX DE,HL
		ADC HL,HL
		DEC A
		JR NZ,.L1
		POP BC
; полный размер FAT-области в секторах
		CALL HLDEPBC
; прибавили ROOTDIRSECTORS
		LD BC,(BUF_512+0x0E)
; BPB_RSVDSECCNT
		LD (RSVDSEC),BC
		CALL HLDEPBC
; прибавили BPB_RESVDSECCNT
		LD (FRSTDAT),DE
		LD (FRSTDAT+2),HL
; положили номер первого сектора данных
		LD B,H
		LD C,L
		LD HL,SEC_DSC
; BCDE + 32-ое число по адресу HL
		CALL BCDEHLM
; вычли из полного к-ва секторов раздела
		LD A,(BUF_512+0x0D)
		LD (BYTSSEC),A
		CALL BCDE_A
; разделили на количество секторов в кластере
		LD (CLS_DSC),DE
		LD (CLS_DSC+2),BC
; положили кол-во кластеров на разделе

		LD A,(CAL_FAT)
		CP 0xFF
		JR NZ,RDFAT04
		LD HL,(CLS_DSC)
		LD DE,(CLS_DSC+2)
		PUSH HL
		PUSH DE
		ADD HL,HL
		EX DE,HL
		ADC HL,HL
		LD B,H
		LD C,L
		CALL RASCHET
		LD A,1
		POP DE
		POP HL
		JR Z,RDFAT04
		ADD HL,HL
		EX DE,HL
		ADC HL,HL
		EX DE,HL
		ADD HL,HL
		EX DE,HL
		ADC HL,HL
		LD B,H
		LD C,L
		CALL RASCHET
		LD A,2
		JR Z,RDFAT04
		XOR A

; для FAT12/16 вычисляем адрес первого
; сектора директории
; для FAT32 берем по смещению +44
; на выходе BCDE-сектор ROOTDIR
RDFAT04
		PUSH AF
		LD DE,(RSVDSEC)
		LD BC,0
		LD HL,STARTRZ
		CALL BCDEHLP
		LD (FATSTR),DE
		LD (FATSTR+2),BC
		POP AF
		LD (CAL_FAT),A
		AND A
		LD DE,0
		LD B,D
		LD C,E
		JR Z,FSRROO2			;FAT12-NONE
		DEC A
		JR Z,FSRROO2			;FAT16
		LD DE,(BUF_512+0x2C)
		LD BC,(BUF_512+0x2E)		;FAT32
FSRROO2
		LD (ROOTCLS),DE
		LD (ROOTCLS+2),BC
; сектор root директории

		LD HL,(ADRPATH)
FINDFL1		PUSH HL
		LD HL,TDIRCLS
		LD A,D
		OR E
		OR B
		OR C
		CALL SAVEZP
		JR Z,LASTCLS
NEXTCLS
		PUSH HL
		CALL RDFATZP
		CALL LST_CLS
		POP HL
		JR C,LASTCLS
		CALL SAVEZP
		JR NEXTCLS

LASTCLS
		LD BC,0xFFFF
		CALL SAVEZP
FINDFL		INC BC
		CALL RDDIRSC
		LD A,C
		AND 0x0F
		LD E,A
		LD D,0
		EX DE,HL
		ADD HL,HL
		ADD HL,HL
		ADD HL,HL
		ADD HL,HL
		ADD HL,HL
		ADD HL,DE
		LD A,(HL)
		AND A
		LD A,0xAA
		INC SP
		INC SP
		RET Z
		DEC SP
		DEC SP
		PUSH HL
		PUSH BC
		CALL COMPARE
		POP BC
		POP DE
		LD IXH,D
		LD IXL,E
		JR NZ,FINDFL
		CALL RD_CLAS
		EX (SP),HL
		POP HL
		LD A,(IX+0x0B)
		AND 0x10
		LD A,0xAA
		RET NZ
		LD (AFILCLS),DE
		LD (AFILCLS+2),BC		; BCDE - номер кластера файла
		CALL LOADZP
		LD A,E
		AND A
		JR Z,.L1
		INC D
		JR NZ,.L1
		INC BC
.L1		BIT 0,D
		JR Z,.L2
		INC D
		JR NZ,.L2
		INC BC
.L2		CALL BCDE200
		PUSH DE
		EXX
		POP HL
		LD A,(BYTSSEC)
		LD IXH,A
		EXX
		XOR A
		RET

SAVEZP
		LD (HL),E
		INC HL
		LD (HL),D
		INC HL
		LD (HL),C
		INC HL
		LD (HL),B
		INC HL
		RET

LOADZP
		LD E,(HL)
		INC HL
		LD D,(HL)
		INC HL
		LD C,(HL)
		INC HL
		LD B,(HL)
		INC HL
		RET

; чтение сектора dir по номеру BC
RDDIRSC
		PUSH BC
		LD D,B
		LD E,C
		LD BC,0
		LD A,0x10
		CALL BCDE_A
		LD A,E
		PUSH AF
		LD A,(BYTSSEC)
		PUSH AF
		CALL BCDE_A
		LD HL,TDIRCLS
		EX DE,HL
		ADD HL,HL
		ADD HL,HL
		ADD HL,DE
		CALL LOADZP
		CALL REALSEC
		POP AF
		DEC A
		LD L,A
		POP AF
		AND L
		LD L,A
		LD H,0
		ADD HL,DE
		EX DE,HL
		LD HL,0
		ADC HL,BC
		LD B,H
		LD C,L
		CALL LOADLST
		POP BC
		RET

LST_CLS		LD A,(CAL_FAT)
		AND A
		JR NZ,LST_CL1
		LD HL,0x0FF7
		SBC HL,DE
		RET

LST_CL1		DEC A
		JR NZ,LST_CL2
LST_CL3		LD HL,0xFFF7
		SBC HL,DE
		RET

LST_CL2		LD HL,0x0FFF
		SBC HL,BC
		RET NZ
		JR LST_CL3

RDFATZP
		LD BC,(AFILCLS+2)
		LD DE,(AFILCLS)
		LD A,(CAL_FAT)
		AND A
		JR Z,RDFATS0
		DEC A
		JR Z,RDFATS1
		EX DE,HL
		ADD HL,HL
		EX DE,HL
		LD HL,0
		ADC HL,BC
		ADD HL,BC
		LD A,E
		LD E,D
		LD D,L
		LD C,H
		LD B,0
		CALL RDFATS2
		INC HL
		LD C,(HL)
		INC HL
		LD B,(HL)
RDFATS5		LD (AFILCLS+2),BC
		LD (AFILCLS),DE
		RET

RDFATS1		LD BC,0
		LD A,E
		LD E,D
		LD D,C
RDFATS2		PUSH AF
		PUSH BC
		LD HL,FATSTR
		CALL BCDEHLP
		CALL LOADLST
		POP BC
		POP AF
		LD E,A
		LD D,0
		ADD HL,DE
		ADD HL,DE
		LD E,(HL)
		INC HL
		LD D,(HL)
		JR RDFATS5

RDFATS0		LD H,D
		LD L,E
		ADD HL,HL
		ADD HL,DE
		SRL H
		RR L
		LD A,E
		LD E,H
		LD D,0
		LD B,D
		LD C,D
		SRL E
		PUSH AF
		PUSH HL
		LD HL,FATSTR
		CALL BCDEHLP
		CALL LOADLST
		POP BC
		LD A,B
		AND 1
		LD B,A
		ADD HL,BC
		LD B,(HL)
		INC HL
		LD A,H
		CP HIGH (BUF_512)+2
		JR NZ,RDFATS4
		PUSH BC
		LD BC,0
		INC DE
		CALL LOADLST
		POP BC
RDFATS4		POP AF
		LD D,(HL)
		LD E,B
		LD BC,0
		RRA
		JR NC,RDFATS3
		SRL D
		RR E
		SRL D
		RR E
		SRL D
		RR E
		SRL D
		RR E
RDFATS3		LD A,D
		AND 0x0F
		LD D,A
		RET

; вычисление реального сектора
; на входе: BCDE = номер кластера
; на выходе: BCDE = номер сектора
REALSEC
		LD BC,(AFILCLS+2)
		LD DE,(AFILCLS)
		LD A,B
		OR C
		OR D
		OR E
		JR NZ,REALSE1
		LD HL,SEC_FAT
		LD DE,(FATSTR)
		LD BC,(FATSTR+2)
		LD HL,SEC_FAT
		LD A,(MANYFAT)
.L0		DEC A
		JP Z,BCDEHLP
		PUSH HL
		PUSH AF
		CALL BCDEHLP
		POP AF
		POP HL
		JP .L0

REALSE1
		LD HL,0xFFFE
		EX DE,HL
		ADD HL,DE
		EX DE,HL
		INC HL
		ADC HL,BC
; номер кластера-2
		LD A,(BYTSSEC)
		JR REALSE2

REALSE3
		SLA E
		RL D
		RL L
		RL H
REALSE2		RRCA
		JR NC,REALSE3
; умножили на размер кластера
		LD B,H
		LD C,L
		LD HL,STARTRZ
		CALL BCDEHLP
; прибавили смещение от начала диска
		LD HL,FRSTDAT
		JP BCDEHLP
; прибавили смещение от начала раздела

BCDE200
		LD E,D
		LD D,C
		LD C,B
		LD B,0
		LD A,2
		JR BCDE_A

; BCDE >> A = BCDE
BCDE_A1
		SRL B
		RR C
		RR D
		RR E
BCDE_A		RRCA
		JR NC,BCDE_A1
		RET

; (ADR) - BCDE = BCDE
BCDEHLM
		LD A,(HL)
		INC HL
		SUB E
		LD E,A
		LD A,(HL)
		INC HL
		SBC A,D
		LD D,A
		LD A,(HL)
		INC HL
		SBC A,C
		LD C,A
		LD A,(HL)
		SBC A,B
		LD B,A
		RET

; (ADR) + BCDE = BCDE
BCDEHLP
		LD A,(HL)
		INC HL
		ADD A,E
		LD E,A
		LD A,(HL)
		INC HL
		ADC A,D
		LD D,A
		LD A,(HL)
		INC HL
		ADC A,C
		LD C,A
		LD A,(HL)
		ADC A,B
		LD B,A
		RET

; HLDE + BC = HLDE
HLDEPBC
		EX DE,HL
		ADD HL,BC
		EX DE,HL
		LD BC,0
		ADC HL,BC
		RET

; определятор разрядности FAT
RASCHET
		CALL BCDE200
		LD HL,SEC_FAT
		CALL BCDEHLM
		LD A,E
		AND 0xF0
		OR D
		OR C
		OR B
		RET

; грузилка одного сектора
LOADLST
		LD HL,BUF_512
		LD A,1
		PUSH HL
		CALL RDMULTI
		POP HL
		RET

OUTCOM
		PUSH BC
		LD BC,0x0600+SD_SEND
		OTIR
		POP BC
		RET

OUT_COM		PUSH BC
		LD BC,SD_SEND
		OUT (C),A
		XOR A
		OUT (C),A
		NOP
		OUT (C),A
		NOP
		OUT (C),A
		NOP
		OUT (C),A
		DEC A
		OUT (C),A
		POP BC
		RET

SECM200
		PUSH HL
		PUSH BC
		LD A,CMD_58
		CALL OUT_COM
		CALL IN_OOUT
		LD BC,SD_RSTR
		IN H,(C)
		NOP
		IN A,(C)
		NOP
		IN A,(C)
		NOP
		IN A,(C)
		BIT 6,H
		POP HL
		JR NZ,SECN200
		EX DE,HL
		ADD HL,HL
		EX DE,HL
		ADC HL,HL
		LD H,L
		LD L,D
		LD D,E
		LD E,0
SECN200
		LD A,CMD_18
		LD C,SD_SEND
		OUT (C),A
		NOP
		OUT (C),H
		NOP
		OUT (C),L
		NOP
		OUT (C),D
		NOP
		OUT (C),E
		LD A,0xFF
		OUT (C),A
		POP HL
		RET

IN_OOUT
		PUSH DE
		LD DE,0x20FF
IN_WAIT		IN A,(SD_RSTR)
		CP E
		JR NZ,IN_EXIT
IN_NEXT
		DEC D
		JR NZ,IN_WAIT
IN_EXIT		POP DE
		RET

CMD00		DB 0x40,0x00,0x00,0x00,0x00,0x95	; GO_IDLE_STATE
CMD08		DB 0x48,0x00,0x00,0x01,0xAA,0x87	; SEND_IF_COND
CMD16		DB 0x50,0x00,0x00,0x02,0x00,0xFF	; SET_BLOCKEN

RDMULTI
		PUSH BC
		PUSH DE
		EX AF,AF'
		CALL SECM200
		EX AF,AF'
		LD BC,SD_RSTR
RDMULT1		EX AF,AF'
.L1		CALL IN_OOUT
		CP 0xFE
		JR NZ,.L1
		INIR
		NOP
		INIR
		NOP
		IN A,(C)
		NOP
		IN A,(C)
		EX AF,AF'
		DEC A
		JR NZ,RDMULT1
		LD A,CMD_12
		CALL OUT_COM
.L2		CALL IN_OOUT
		INC A
		JR NZ,.L2
		POP DE
		POP BC
		RET

; выборка номера кластера из файлового описателя
RD_CLAS		EX DE,HL
		LD DE,0x14
		ADD HL,DE
		LD C,(HL)
		INC HL
		LD B,(HL)
		LD E,5
		ADD HL,DE
		LD E,(HL)
		INC HL
		LD D,(HL)
		INC HL
		RET

COMPARE
		LD DE,F_PATH
		LD B,8 + 3
.L1		LD A,(DE)
		CP (HL)
		RET NZ
		INC HL
		INC DE
		DJNZ .L1
		RET

NOTFOUND
		XOR A
		CALL 0x1601
		LD DE,TXT_ERROR
		LD BC,ETXT_ERROR - TXT_ERROR
		CALL 0x203C
		DI
		HALT

TXT_ERROR	DB "File \"",BOOTNAME,"\" not found.\rPress RESET"
ETXT_ERROR

; имя файла (8 + 3 + 1)
F_PATH
		DB BOOTNAME
		DB 0

PEREM		EQU (HIGH ($) + 1) * 0x100
