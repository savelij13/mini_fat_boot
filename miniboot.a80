
; LAST UPDATE 01.07.2021 savelij

; загрузчик и запускатель файлов в Hobeta формате с SD карты

		include ../../yad/svn/pentevo/rom/macros.a80
		include ../../yad/svn/pentevo/rom/sdcomand.a80
		include ../../yad/svn/pentevo/rom/bootsecfat.a80
		include define.a80

SD_RSTR		EQU P_DATA
SD_SEND		EQU P_DATA

NO_MBR		EQU 0

; Входные параметры общие:
; HL-адрес загрузки в память
; BCDE-32-х битный номер сектора
; A-количество блоков (блок=512 байт)
; только для многоблочной записи/чтении

; Ошибки выдаваемые на выходе:
; A=0-инициализация прошла успешно
; A=1-карта не найдена или не ответила
; A=2-карта защищена от записи
; A=3-попытка записи в сектор 0 карты

 INIT_VAR PEREM
 SETVAR TDIRCLS,		0x400	;EQU PEREM		; 0x400 буфер кластеров ROOT директории
 SETVAR BUF_512,		0x200	;EQU TDIRCLS+0x0400	; 0x200 буфер сектора
 SETVAR CAL_FAT,		BYTE	;EQU BUF_512+0x0200	; 1 калибр FAT
 SETVAR MANYFAT,		BYTE
 SETVAR BYTSSEC,		BYTE	;EQU CAL_FAT+1		; 1 количество секторов в кластере
 SETVAR SEC_FAT,		DWORD	;EQU ROOTSEC+2		; 4 количество секторов одной FAT
 SETVAR STARTRZ,		DWORD	;EQU RSVDSEC+2		; 4 начало диска/раздела
 SETVAR FRSTDAT,		DWORD	;EQU STARTRZ+4		; 4 адрес первого сектора данных от BPB
 SETVAR CLS_DSC,		DWORD	;EQU SEC_DSC+4		; 4 количество кластеров на диске/разделе
 SETVAR ADRPATH,		WORD	;EQU FB_EXT+0x0B	; 2 адрес пути к имени файла
 SETVAR LENGHT,			WORD
 SETVAR NUM_SEC_FAT1,		DWORD				; номер сектора первой FAT таблицы
 SETVAR NUM_SEC_FAT2,		DWORD				; номер сектора второй FAT таблицы
 SETVAR NUM_SEC_ROOTDIR,	DWORD				; номер сектора корневой директории
 SETVAR CLUSTER_FILE,		DWORD				; текущий номер кластера файла

		ORG ADRLOAD
		DI
		LD SP,0x5FFF
		LD BC,0x7FFD
		LD A,0x10
		OUT (C),A
		LD HL,F_PATH
		CALL START			; инициализация SD карты, FAT и поиска файла
		AND A
		JP NZ,NOTFOUND			; файл не найден

		CALL REALSEC			; преобразовали в номер сектора
		CALL LOADLST			; загрузили в буфер
		EXX
		LD HL,(BUF_512+9)
		LD (RUN_ADR),HL			; адрес старта кода
		LD HL,(BUF_512+0X0B)
		LD (LENGHT),HL			; установка длины файла в байтах
		LD DE,0x11
		ADD HL,DE			; пропуск Hobeta заголовка
		LD A,L
		AND A
		JR Z,READ01			; если младший байт не 0
		INC H				; старший +1
READ01		LD A,H
		SRL A				; делим на 2 ибо на FAT сектор 512 байт
		ADC A,0				; учитываем чет/нечет
		DEC A				; первый сектор загружен, грузить на 1 меньше
		EXX
		JP Z,LDIRBUF			; если сектор 1 перенос и запуск
		DEC A
		LD IXL,A			; запомнили количество секторов-1
		JP Z,READ08			; если секторов 2 осталось загрузить кусок из второго сектора
		EXX
		CALL LD_ONES			; перенос остатков первого сектора
		PUSH DE				; адрес куда далее грузить
		EXX
		LD HL,1				; один сектор уже загружен
		ADD HL,DE			; далее грузить со следующего сектора 
		EX DE,HL
		JR NC,READ04
		INC BC				; BCDE++
READ04		POP HL				; в HL адрес для продолжения загрузки
		LD IY,(BYTSSEC)			; LY = количество секторов в кластере
		LD A,IXL
		CP IYL				; секторов осталось меньше чем в кластере
		JR C,READ02			; переход на дозагрузку остатка секторов
		INC IXL
		LD A,IYL
		CP 2
		JR C,READ07
		DEC A
		JR READ05

READ07		PUSH HL
		LD DE,(CLUSTER_FILE)
		LD BC,(CLUSTER_FILE + 2)
		CALL RDFATZP			; получить номер следующего кластера
		LD (CLUSTER_FILE),DE
		LD (CLUSTER_FILE + 2),BC
		CALL LST_CLS			; проверка на окончание FAT цепочки
		POP HL
		JR C,RUNLOAD			; если кластера закончились, то запуск загруженного
		PUSH HL
		CALL REALSEC			; преобразование номера кластера в номер сектора
		POP HL
		LD A,IXL			; сколько секторов осталось загрузить
		CP IYL				; сравниваем с размером кластера
		JR C,READ02			; если осталось загрузить секторов меньше чем в кластере, то дозагружаем остаток
		LD A,IYL			; сколько секторов загружать
READ05		CALL RDMULTI			; загрузка секторов
		LD A,IXL			; сколько секторов всего загружать
		SUB IYL				; минус сколько секторов только что загрузили
		JR Z,RUNLOAD			; сектора кончились, переходим на запуск
		LD IXL,A			; сколько секторов осталось загрузить
		JR READ07			; продолжаем загрузку

; размер кода в Hobeta менее 2 секторов
; копируем хвост первого сектора и догружаем из второго с переносом
READ08		EXX
		CALL LD_ONES
		PUSH DE
		EXX
		POP HL
		LD IXL,1
		JR READ03

; загрузка количества секторов, если осталось менее размера кластера
READ02		AND A
		JR Z,READ03
		CALL RDMULTI
READ03		PUSH HL
		LD A,IXL
		LD L,A
		LD H,0
		ADD HL,DE
		EX DE,HL
		JR NC,READ06
		INC BC
READ06		CALL LOADLST
		LD BC,(LENGHT)
		EX DE,HL
		LD HL,0X11
		ADD HL,BC
		LD B,H
		LD C,L
		EX DE,HL
		POP DE
		LD A,B
		AND 1
		LD B,A
		OR C
		JR Z,RUNLOAD
		LDIR
; запуск загруженного
RUNLOAD		LD HL,0X2758
		EXX
		LD IY,0x5C3A
		LD A,0x3F
		LD I,A
		IM 1
		EI
		JP 0			; запуск загруженного кода
RUN_ADR		EQU $-2

LDIRBUF		LD HL,0X200-0X11
		LD DE,(BUF_512+0X0B)
		AND A
		SBC HL,DE
		JR NC,LDIRBUF1
		CALL LD_ONES
		JP RUNLOAD

LDIRBUF1	LD HL,BUF_512+0X11
		LD DE,(BUF_512+9)
		LD BC,(BUF_512+0X0B)
		LDIR
		JP RUNLOAD

; перенос куска из уже загруженного сектора, если файл=501 байт и менее
LD_ONES		LD HL,BUF_512+0X11
		LD DE,(BUF_512+9)
		LD BC,0X200-0X11
		LDIR
		RET

; выдача ошибки "нет карточки"
ZAW003
		LD A,0xEE
		RET

; инициализация SD карты, FAT и поиск файла по имени
; на входе:
; HL - имя файла
; на выходе:
; BCDE - номер калстера файла
START
		LD (ADRPATH),HL

; ---------------------------------
; для Z-контроллера
		LD A,3
		OUT (P_CONF),A
		XOR A
		OUT (P_DATA),A
		LD BC,P_DATA
		LD DE,0x10FF
.L1		OUT (C),E
		DEC D
		JR NZ,.L1
		LD A,1
		OUT (P_CONF),A
		XOR A
		EX AF,AF'
;---------------------------------

ZAW001
		LD HL,CMD00
		CALL OUTCOM
		CALL IN_OOUT
		EX AF,AF'
		DEC A
		JR Z,ZAW003
		EX AF,AF'
		DEC A
		JR NZ,ZAW001
		LD BC,SD_RSTR
		LD HL,CMD08
		CALL OUTCOM
		CALL IN_OOUT
		IN H,(C)
		NOP
		IN H,(C)
		NOP
		IN H,(C)
		NOP
		IN H,(C)
		BIT 2,A
		LD HL,0
		JR NZ,ZAW006
		LD H,0x40
ZAW006		LD A,CMD_55
		CALL OUT_COM
		CALL IN_OOUT
		LD BC,SD_SEND
		LD A,ACMD_41
		OUT (C),A
		LD A,H
		OUT (C),A
		XOR A
		OUT (C),A
		NOP
		OUT (C),A
		NOP
		OUT (C),A
		DEC A
		OUT (C),A
		CALL IN_OOUT
		AND A
		JR NZ,ZAW006
ZAW004
		LD A,CMD_59
		CALL OUT_COM
		CALL IN_OOUT
		AND A
		JR NZ,ZAW004
ZAW005
		LD HL,CMD16
		CALL OUTCOM
		CALL IN_OOUT
		AND A
		JR NZ,ZAW005
; инициализация SD карты закончена

; инициализация переменных FAT
WC_FAT
		LD DE,0
		LD B,D
		LD C,E
		CALL LOADLST
		PUSH HL
		POP IX
		LD DE,0x01BE
		ADD HL,DE
	IF NO_MBR
		LD A,(HL)
		AND A
		JR NZ,RDFAT05
	ENDIF
		LD DE,4
		ADD HL,DE
		LD A,(HL)

		LD B,0			; FAT12
		CP 1
		JR Z,RDFAT06

		LD B,2			; FAT32
		CP 0x0B
		JR Z,RDFAT06
		CP 0x0C
		JR Z,RDFAT06

		LD B,1			; FAT16
		CP 4
		JR Z,RDFAT06
		CP 6
		JR Z,RDFAT06
		CP 0x0E
	IF NO_MBR
		JR NZ,RDFAT05
	ELSE
		LD A,0xDD
		RET NZ
	ENDIF
; тип FAT взят из описателя MBR
RDFAT06
		LD A,B
		LD (CAL_FAT),A
		ADD HL,DE
		CALL LOADZP
		JR RDFAT00

; MBR не найдена, попытка определить тип FAT из сектора 0
	IF NO_MBR
RDFAT05
		LD C,(IX + _BPB_SecPerClus)
		XOR A
		LD E,A
		LD B,8
.L1		RR C
		ADC A,0
		DJNZ .L1
		DEC A
		JR NZ,.L2
		INC E
.L2		LD A,(IX + _BPB_RsvdSecCnt)
		OR (IX + _BPB_RsvdSecCnt + 1)
		JR Z,.L3
		INC E
.L3		LD A,(IX + _BPB_TotSec16)
		OR (IX + _BPB_TotSec16 + 1)
		JR NZ,.L4
		INC E
.L4		LD A,(IX + _BPB_TotSec32)
		OR (IX + _BPB_TotSec32 + 1)
		OR (IX + _BPB_TotSec32 + 2)
		OR (IX + _BPB_TotSec32 + 3)
		JR NZ,.L5
		INC E
.L5		LD A,(IX + _BPB_Media)
		AND 0xF0
		CP 0xF0
		JR NZ,.L6
		INC E
.L6		LD A,E
		CP 4
		LD A,0xDD
		RET NZ
		LD A,0xFF
		LD (CAL_FAT),A
		LD DE,0
		LD B,D
		LD C,E
	ENDIF

RDFAT00
		LD (STARTRZ),DE
		LD (STARTRZ + 2),BC			; номер сектора начала раздела
		CALL LOADLST
		LD A,(BUF_512 + _BPB_SecPerClus)
		LD (BYTSSEC),A
		LD HL,(BUF_512 + _BPB_RsvdSecCnt)
		ADD HL,DE
		LD (NUM_SEC_FAT1),HL
		LD HL,0
		ADC HL,BC
		LD (NUM_SEC_FAT1 + 2),HL	; начало первой FAT таблицы

		LD HL,0
		LD DE,(BUF_512 + _BPB_FATSz16)		
		LD A,D
		OR E
		JR NZ,RDFAT01
; если не FAT12/16 (BPB_FATSZ16=0)
		LD DE,(BUF_512 + _BPB_FATSz32)
		LD HL,(BUF_512 + _BPB_FATSz32 + 2)
; то берем из смещения +36
RDFAT01
		LD (SEC_FAT+2),HL
		LD (SEC_FAT),DE
; число секторов на FAT-таблицу

; вычисляем ROOTDIRSECTORS
		LD DE,(BUF_512 + _BPB_RootEntCnt)
		LD HL,0
		LD A,D
		OR E
		JR Z,RDFAT03
		LD B,H
		LD C,L
		LD A,0x10
		CALL BCDE_A

; это реализована формула
; ROOTDIRSECTORS = ((BPB_ROOTENTCNT*32) + (BPB_BYTSPERSEC-1)) / BPB_BYTSPERSEC
; в HL ROOTDIRSECTORS
; если FAT32, то HL=0 всегда

RDFAT03		PUSH DE				; ROOTDIRSECTORS
		LD A,(BUF_512 + _BPB_NumFATs)
		LD (MANYFAT),A
		DEC A
		JR Z,.L1
		LD HL,NUM_SEC_FAT1
		CALL LOADZP
		LD HL,SEC_FAT
		CALL BCDEHLP
		LD (NUM_SEC_FAT2),DE
		LD (NUM_SEC_FAT2 + 2),BC
.L1		LD HL,SEC_FAT
		CALL BCDEHLP
		LD (NUM_SEC_ROOTDIR),DE
		LD (NUM_SEC_ROOTDIR + 2),BC
		POP HL
; добавляем размер ROOTDIR
		ADD HL,DE
		EX DE,HL
		LD HL,0
		ADC HL,BC
		ADD HL,BC
		LD B,H
		LD C,L
		LD (FRSTDAT),DE
		LD (FRSTDAT + 2),BC

	IF NO_MBR
		LD A,(CAL_FAT)
		CP 0xFF
		JR NZ,RDFAT04
		LD HL,(CLS_DSC)
		LD DE,(CLS_DSC+2)
		PUSH HL
		PUSH DE
		ADD HL,HL
		EX DE,HL
		ADC HL,HL
		LD B,H
		LD C,L
		CALL RASCHET
		LD A,1
		POP DE
		POP HL
		JR Z,.L1
		ADD HL,HL
		EX DE,HL
		ADC HL,HL
		EX DE,HL
		ADD HL,HL
		EX DE,HL
		ADC HL,HL
		LD B,H
		LD C,L
		CALL RASCHET
		LD A,2
		JR Z,.L1
		XOR A
.L1		LD (CAL_FAT),A
	ENDIF

; для FAT12/16 вычисляем адрес первого
; сектора директории
; для FAT32 берем по смещению +44
; на выходе BCDE-сектор ROOTDIR
RDFAT04		LD A,(CAL_FAT)
		AND A
		LD DE,0
		LD B,D
		LD C,E
		JR Z,FSRROO2			;FAT12-NONE
		DEC A
		JR Z,FSRROO2			;FAT16
		LD DE,(BUF_512 + _BPB_RootClus)
		LD BC,(BUF_512 + _BPB_RootClus + 2)		;FAT32
FSRROO2
		LD HL,(ADRPATH)
FINDFL1		PUSH HL
		LD HL,TDIRCLS
		LD A,D
		OR E
		OR B
		OR C
		CALL SAVEZP
		JR Z,LASTCLS
NEXTCLS		PUSH HL
		CALL RDFATZP
		CALL LST_CLS
		POP HL
		JR C,LASTCLS
		CALL SAVEZP
		JR NEXTCLS

LASTCLS		LD BC,0xFFFF
		CALL SAVEZP
FINDFL		INC BC
		CALL RDDIRSC
		LD A,C
		AND 0x0F
		LD E,A
		LD D,0
		EX DE,HL
		ADD HL,HL
		ADD HL,HL
		ADD HL,HL
		ADD HL,HL
		ADD HL,HL
		ADD HL,DE
		LD A,(HL)
		AND A
		LD A,0xAA
		INC SP
		INC SP
		RET Z
		DEC SP
		DEC SP
		PUSH HL
		PUSH BC
		CALL COMPARE
		POP BC
		POP DE
		LD IXH,D
		LD IXL,E
		JR NZ,FINDFL
		CALL RD_CLAS
		EX (SP),HL
		POP HL
		LD A,(IX+0x0B)
		AND 0x10
		LD A,0xAA
		RET NZ
		PUSH BC
		PUSH DE
		LD (CLUSTER_FILE),DE
		LD (CLUSTER_FILE + 2),BC	; BCDE - номер кластера файла
		CALL LOADZP
		LD A,E
		AND A
		JR Z,.L1
		INC D
		JR NZ,.L1
		INC BC
.L1		BIT 0,D
		JR Z,.L2
		INC D
		JR NZ,.L2
		INC BC
.L2		CALL BCDE200
		PUSH DE
		EXX
		POP HL
		LD A,(BYTSSEC)
		LD IXH,A
		EXX
		XOR A
		POP DE
		POP BC
		RET

SAVEZP		LD (HL),E
		INC HL
		LD (HL),D
		INC HL
		LD (HL),C
		INC HL
		LD (HL),B
		INC HL
		RET

LOADZP		LD E,(HL)
		INC HL
		LD D,(HL)
		INC HL
		LD C,(HL)
		INC HL
		LD B,(HL)
		INC HL
		RET

; чтение сектора dir по номеру BC
RDDIRSC		PUSH BC
		LD D,B
		LD E,C			; номер записи в DIR
		LD BC,0
		LD A,0x10
		CALL BCDE_A		; BCDE - номер сектора
		LD A,E
		PUSH AF
		LD A,(BYTSSEC)
		PUSH AF
		CALL BCDE_A
		LD HL,TDIRCLS
		EX DE,HL
		ADD HL,HL
		ADD HL,HL
		ADD HL,DE
		CALL LOADZP
		CALL REALSEC
		POP AF
		DEC A
		LD L,A
		POP AF
		AND L
		LD L,A
		LD H,0
		ADD HL,DE
		EX DE,HL
		LD HL,0
		ADC HL,BC
		LD B,H
		LD C,L
		CALL LOADLST
		POP BC
		RET

LST_CLS		LD A,(CAL_FAT)
		AND A
		JR NZ,LST_CL1
		LD HL,0x0FF7
		SBC HL,DE
		RET

LST_CL1		DEC A
		JR NZ,LST_CL2
LST_CL3		LD HL,0xFFF7
		SBC HL,DE
		RET

LST_CL2		LD HL,0x0FFF
		SBC HL,BC
		RET NZ
		JR LST_CL3

RDFATZP		LD A,(CAL_FAT)
		AND A
		JR Z,RDFATS0
		DEC A
		JR Z,RDFATS1
		EX DE,HL
		ADD HL,HL
		EX DE,HL
		LD HL,0
		ADC HL,BC
		ADD HL,BC		; HLDE = BCDE * 2
		LD A,E
		LD E,D
		LD D,L
		LD C,H
		LD B,0
		CALL RDFATS2
		INC HL
		LD C,(HL)
		INC HL
		LD B,(HL)
		RET

RDFATS1		LD BC,0
		LD A,E
		LD E,D
		LD D,C
RDFATS2		PUSH AF
		PUSH BC
		LD HL,NUM_SEC_FAT1
		CALL BCDEHLP
		CALL LOADLST
		POP BC
		POP AF
		LD E,A
		LD D,0
		ADD HL,DE
		ADD HL,DE
		LD E,(HL)
		INC HL
		LD D,(HL)
		RET

RDFATS0		LD H,D
		LD L,E
		ADD HL,HL
		ADD HL,DE
		SRL H
		RR L
		LD A,E
		LD E,H
		LD D,0
		LD B,D
		LD C,D
		SRL E
		PUSH AF
		PUSH HL
		LD DE,(NUM_SEC_FAT1)
		LD BC,(NUM_SEC_FAT1 + 2)
		CALL LOADLST
		POP BC
		LD A,B
		AND 1
		LD B,A
		ADD HL,BC
		LD B,(HL)
		INC HL
		LD A,H
		CP HIGH (BUF_512) + 2
		JR NZ,RDFATS4
		PUSH BC
		LD BC,0
		INC DE
		CALL LOADLST
		POP BC
RDFATS4		POP AF
		LD D,(HL)
		LD E,B
		LD BC,0
		RRA
		JR NC,RDFATS3
	REPT 4
		SRL D
		RR E
	ENDM
RDFATS3		LD A,D
		AND 0x0F
		LD D,A
		RET

; вычисление реального сектора
; на входе: BCDE = номер кластера
; на выходе: BCDE = номер сектора
REALSEC		LD A,B
		OR C
		OR D
		OR E
		JR NZ,REALSE1
		LD DE,(NUM_SEC_ROOTDIR)
		LD BC,(NUM_SEC_ROOTDIR + 2)
		RET

REALSE1		LD HL,0xFFFE
		EX DE,HL
		ADD HL,DE
		EX DE,HL
		INC HL
		ADC HL,BC
; номер кластера-2
		LD A,(BYTSSEC)
		JR REALSE2

REALSE3
		SLA E
		RL D
		RL L
		RL H
REALSE2		RRCA
		JR NC,REALSE3
; умножили на размер кластера
		LD B,H
		LD C,L
; прибавили смещение от начала диска
		LD HL,FRSTDAT
		JP BCDEHLP
; прибавили смещение от начала раздела

BCDE200
		LD E,D
		LD D,C
		LD C,B
		LD B,0
		LD A,2
		JR BCDE_A

; BCDE >> A = BCDE
BCDE_A1
		SRL B
		RR C
		RR D
		RR E
BCDE_A		RRCA
		JR NC,BCDE_A1
		RET

; (ADR) - BCDE = BCDE
BCDEHLM
		LD A,(HL)
		INC HL
		SUB E
		LD E,A
		LD A,(HL)
		INC HL
		SBC A,D
		LD D,A
		LD A,(HL)
		INC HL
		SBC A,C
		LD C,A
		LD A,(HL)
		SBC A,B
		LD B,A
		RET

; (ADR) + BCDE = BCDE
BCDEHLP
		LD A,(HL)
		INC HL
		ADD A,E
		LD E,A
		LD A,(HL)
		INC HL
		ADC A,D
		LD D,A
		LD A,(HL)
		INC HL
		ADC A,C
		LD C,A
		LD A,(HL)
		ADC A,B
		LD B,A
		RET

; HLDE + BC = HLDE
HLDEPBC
		EX DE,HL
		ADD HL,BC
		EX DE,HL
		LD BC,0
		ADC HL,BC
		RET

; определятор разрядности FAT
RASCHET		CALL BCDE200
		LD HL,SEC_FAT
		CALL BCDEHLM
		LD A,E
		AND 0xF0
		OR D
		OR C
		OR B
		RET

; грузилка одного сектора
LOADLST		LD HL,BUF_512
		LD A,1
		PUSH HL
		CALL RDMULTI
		POP HL
		RET

OUTCOM		PUSH BC
		LD BC,0x0600+SD_SEND
		OTIR
		POP BC
		RET

OUT_COM		PUSH BC
		LD BC,SD_SEND
		OUT (C),A
		XOR A
		OUT (C),A
		NOP
		OUT (C),A
		NOP
		OUT (C),A
		NOP
		OUT (C),A
		DEC A
		OUT (C),A
		POP BC
		RET

SECM200		PUSH HL
		PUSH BC
		LD A,CMD_58
		CALL OUT_COM
		CALL IN_OOUT
		LD BC,SD_RSTR
		IN H,(C)
		NOP
		IN A,(C)
		NOP
		IN A,(C)
		NOP
		IN A,(C)
		BIT 6,H
		POP HL
		JR NZ,SECN200
		EX DE,HL
		ADD HL,HL
		EX DE,HL
		ADC HL,HL
		LD H,L
		LD L,D
		LD D,E
		LD E,0
SECN200		LD A,CMD_18
		LD C,SD_SEND
		OUT (C),A
		NOP
		OUT (C),H
		NOP
		OUT (C),L
		NOP
		OUT (C),D
		NOP
		OUT (C),E
		LD A,0xFF
		OUT (C),A
		POP HL
		RET

IN_OOUT		PUSH DE
		LD DE,0x20FF
IN_WAIT		IN A,(SD_RSTR)
		CP E
		JR NZ,IN_EXIT
IN_NEXT		DEC D
		JR NZ,IN_WAIT
IN_EXIT		POP DE
		RET

CMD00		DB 0x40,0x00,0x00,0x00,0x00,0x95	; GO_IDLE_STATE
CMD08		DB 0x48,0x00,0x00,0x01,0xAA,0x87	; SEND_IF_COND
CMD16		DB 0x50,0x00,0x00,0x02,0x00,0xFF	; SET_BLOCKEN

RDMULTI		PUSH BC
		PUSH DE
		EX AF,AF'
		CALL SECM200
		EX AF,AF'
		LD BC,SD_RSTR
RDMULT1		EX AF,AF'
.L1		CALL IN_OOUT
		CP 0xFE
		JR NZ,.L1
		INIR
		NOP
		INIR
		NOP
		IN A,(C)
		NOP
		IN A,(C)
		EX AF,AF'
		DEC A
		JR NZ,RDMULT1
		LD A,CMD_12
		CALL OUT_COM
.L2		CALL IN_OOUT
		INC A
		JR NZ,.L2
		POP DE
		POP BC
		RET

; выборка номера кластера из файлового описателя
RD_CLAS		EX DE,HL
		LD DE,0x14
		ADD HL,DE
		LD C,(HL)
		INC HL
		LD B,(HL)
		LD E,5
		ADD HL,DE
		LD E,(HL)
		INC HL
		LD D,(HL)
		INC HL
		RET

; проверка имени файла
COMPARE
		LD DE,F_PATH
		LD B,8 + 3
.L1		LD A,(DE)
		CP (HL)
		RET NZ
		INC HL
		INC DE
		DJNZ .L1
		RET

; файл не найден, вывод текста срествами Basic 48
NOTFOUND
		XOR A
		CALL 0x1601
		LD DE,TXT_ERROR
		LD BC,ETXT_ERROR - TXT_ERROR
		CALL 0x203C
		DI
		HALT

; текст об ошибке если файл не найден
TXT_ERROR	DB "File \"",BOOTNAME,"\" not found.\rPress RESET."
ETXT_ERROR

; имя файла (8 + 3 + 1)
F_PATH
		DB BOOTNAME
		DB 0

PEREM		EQU (HIGH ($) + 1) * 0x100
